/*
   -- New project --
   
   To compile this code using RemoteXY library 4.1.4 or later version 
   download by link http://remotexy.com/en/library/
   To connect using RemoteXY mobile app by link http://remotexy.com/en/download/                   
     - for ANDROID 4.16.02 or later version;
     - for iOS 1.13.1 or later version;
    
   To interact with the GUI, please refer to the manual: 
   https://remotexy.com/ru/help/code/interaction/

   This source code was automatically generated by the RemoteXY editor and 
   is an example for the RemoteXY library. 
   Licensed under the MIT License. See the LICENSE file in the RemoteXY library
   root (https://github.com/RemoteXY/RemoteXY-Arduino-library) for full license 
   details.             
*/

//////////////////////////////////////////////
//        RemoteXY include library          //
//////////////////////////////////////////////

// you can enable debug logging to Serial at 115200
//#define REMOTEXY__DEBUGLOG    

// RemoteXY select connection mode and include library 
#include <SoftwareSerial.h>
#define NUM_SENSORS 6
float points;

// Assign pins for IR sensors (adjust based on your wiring)
int irPins[NUM_SENSORS] = {21, 22, 23, 2, 4, 15};
// Store sensor states
int irState[NUM_SENSORS];

// RemoteXY select connection mode and include library 
#define REMOTEXY_MODE__ESP32CORE_BLE

#include <BLEDevice.h>

// RemoteXY connection settings 
#define REMOTEXY_BLUETOOTH_NAME "RemoteXY"


#include <RemoteXY.h>

// RemoteXY GUI configuration  
#pragma pack(push, 1)  
uint8_t RemoteXY_CONF[] =   // 64 bytes
  { 255,4,0,4,0,57,0,19,0,0,0,0,31,1,106,200,1,1,4,0,
  1,10,168,24,24,0,2,31,72,73,84,0,5,25,105,60,60,0,2,26,
  31,1,72,9,24,24,0,36,31,82,69,83,69,84,0,67,34,68,40,10,
  78,2,26,2 };
  
// this structure defines all the variables and events of your control interface 
struct {

    // input variables
  int8_t joystick_01_x; // from -100 to 100
  int8_t joystick_01_y; // from -100 to 100
  uint8_t button_01; // =1 if button pressed, else =0, from 0 to 1
  uint8_t button_02; // =1 if button pressed, else =0, from 0 to 1

    // output variables
  float POINTS;

    // other variable
  uint8_t connect_flag;  // =1 if wire connected, else =0

} RemoteXY;   

#pragma pack(pop)

#define LEFT_DIR_PIN 14
#define RIGHT_DIR_PIN 26
#define LEFT_PWM_PIN  27
#define RIGHT_PWM_PIN 25


#define LEFT_CH  0
#define RIGHT_CH 1


void setup() {
  Serial.begin(115200);
  RemoteXY_Init();
  pinMode(LEFT_DIR_PIN, OUTPUT);
  pinMode(RIGHT_DIR_PIN, OUTPUT);
  ledcSetup(LEFT_CH, 3000, 8);  // channel 0, 3kHz, 8-bit
  ledcAttachPin(LEFT_PWM_PIN, LEFT_CH);
  ledcSetup(RIGHT_CH, 3000, 8); // channel 1, 3kHz, 8-bit
  ledcAttachPin(RIGHT_PWM_PIN, RIGHT_CH);
  Serial.println("âœ… ESP32 BLE RemoteXY Test Ready");
  points=0;
  // Initialize sensor pins
  for (int i = 0; i < NUM_SENSORS; i++) {
    pinMode(irPins[i], INPUT);
  }

  Serial.println("SumoBot IR Sensor System Initialized!");

  
}

void loop() {
  RemoteXY_Handler();
  int8_t x = RemoteXY.joystick_01_x;
  int8_t y = RemoteXY.joystick_01_y;
  int deadzone = 15;
  if (abs(x) < deadzone) x = 0;
  if (abs(y) < deadzone) y = 0;
  int16_t leftSpeed  = y - x;
  int16_t rightSpeed = y + x;

  leftSpeed  = constrain(leftSpeed, -100, 100);
  rightSpeed = constrain(rightSpeed, -100, 100);

  int leftPWM  = map(abs(leftSpeed), 0, 100, 0, 255);
  int rightPWM = map(abs(rightSpeed), 0, 100, 0, 255);
  int minPWM = 10;
  if (leftPWM < minPWM && leftPWM != 0) leftPWM = minPWM;
  if (rightPWM < minPWM && rightPWM != 0) rightPWM = minPWM;

  if (leftSpeed >= 0) {
     digitalWrite(LEFT_DIR_PIN, HIGH);       // Forward
     ledcWrite(LEFT_CH, leftPWM);            // Speed
    } 
    else {
     digitalWrite(LEFT_DIR_PIN, LOW);        // Reverse
     ledcWrite(LEFT_CH, leftPWM);           // Speed (absolute)
    }
 // Right motor
  if (rightSpeed >= 0) {
     digitalWrite(RIGHT_DIR_PIN, HIGH);      // Forward
     ledcWrite(RIGHT_CH, rightPWM);          // Speed
    } 
    else {
     digitalWrite(RIGHT_DIR_PIN, LOW);       // Reverse
     ledcWrite(RIGHT_CH, rightPWM);         // Speed (absolute)
    }
    bool dangerDetected = false;
 //ir sensor
  for (int i = 0; i < NUM_SENSORS; i++) {
    irState[i] = digitalRead(irPins[i]);

    // IR module: LOW = black detected
    if (irState[i] == HIGH) {
      dangerDetected = true;
      Serial.print("âš   Black zone detected by sensor ");
      Serial.println(i + 1);
    }
  }

  if (dangerDetected) {

    points=points-1;
    Serial.println("ðŸš«Danger Zone Detected!Penalty!");
    Serial.print("Points:");
    Serial.println(points);
    // You can add motor stop or scoring logic here
  } else {
    Serial.println("âœ… All Clear (Safe Zone)");
  }

  delay(500);




  // Print joystick and button values
  // Serial.print(" | ON/OFF: ");
  // Serial.print(RemoteXY.pushSwitch_01);
  Serial.print(" |Joystick X: ");
  Serial.print(RemoteXY.joystick_01_x);
  Serial.print(" | Y: ");
  Serial.print(RemoteXY.joystick_01_y);
  Serial.print(" | HIT: ");
  Serial.print(RemoteXY.button_01);
  Serial.print(" | Connected: ");
  Serial.println(RemoteXY.connect_flag);

  if(RemoteXY.button_02==1)
  {
    points=0;
  }

  RemoteXY.POINTS = points;


  delay(200); // Slow down serial output for readability
}
